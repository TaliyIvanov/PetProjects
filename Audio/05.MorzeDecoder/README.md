### Приветствие

В данном ноутбуке будут мои попытки решить задачу [Декодировщика Морзе](https://www.kaggle.com/competitions/morse-decoder/overview) в рамках попытки попасть на стажировку в Контур (но надо переезжать в другой город, так что на стажировку я не стремлюсь :D)

Иллюзий я не питаю, это один из этапов получения мной опыта в сфере DS по направлению speech =).

### О задаче
#### Основные задачи

1. Создайте модель машинного обучения, способную распознавать код Морзе из аудиосигналов. В вашем распоряжении архив с данными для обучения — morse_dataset.zip.

2. Задача со звёздочкой ⭐: Расшифруйте послание, закодированное в последних 17 аудио файлах архива morse_dataset.zip, и раскройте тайну, которую несёт этот сигнал. Что пытаются донести отправители?
Дополнительные детали, которые могут помочь вам в разгадке тайны, доступны в файле logbook.txt.

#### Метрика качества

Levenshtein Mean — усредненное расстояние Левенштейна по тестовому датасету.

#### Описание данных

- sample_submission.csv – пример отправки в систему оценки

- train.csv – обучающие примеры и расшифровки к ним

- test.csv – тестовый список файлов для оценки, совпадает со списком в sample_submission.csv

- morse_dataset.zip – zip-файл, содержащий аудиофайлы в формате opus, полученные из исходников с частотой дискретизации 8кГц

- logbook.txt – журнал обмена сообщениями колонии

#### Немного бла бла и рассуждений о задаче перед началомю

Как следует из [Вики](https://ru.wikipedia.org/wiki/%D0%90%D0%B7%D0%B1%D1%83%D0%BA%D0%B0_%D0%9C%D0%BE%D1%80%D0%B7%D0%B5) суть азбуки Морзе достаточно проста:

- Каждая буква и цифра (далее - знак) кодируются последовательностью точек, тире и пауз между ними;
- За условную единицу времени принимается длительность самого короткого сигнала - точки;
- Длительность **ТИРЕ** соответствует длительности 3ех точек;
- Длительность **ПАУЗЫ** между **элементами** кода одного знака равна одной точке;
- Длительность **ПАУЗЫ** между **знаками** одного слова равна 3ем точкам;
- Длительность **ПАУЗЫ** между **словами** равна 7ми точкам.


Код может передаваться с любой доступной скоростью, причём возможность декодирования сохраняется и при значительных неточностях в соблюдении временных интервалов.

Глобально я вижу следующее:
- Переводим транскрипции в строку-морзе;
- Избавляемся от шумов на аудио (по идее это делается с помощью разложения Фурье);
- Далее идет бинарная классификация 1 - есть сигнал, 0 - нет сигнала;
- Алгоритм выявляет условную единицу длительности (длительность точки);
- Классифицирует по длительности 1 - точка или тире, по длительности 0 - пауза между символами или словами;
- Выдает нам строку-последовательность символов;
- Простой функцией дешифруем эту строку с помощью словаря ключ-значение;
- Оцениваем результат.

Но, постольку поскольку, у меня есть только: наименование файла, транскрипция и мало времени, я думаю стоит уделить время поиску и рассмотрению готовых решений для решения данной задачи.

В целом, конечно можно заморочиться и создавать новую фичу "кода морзе" вместо буквенной записи, но чот мне не очень охота. (Возможно я передумаю)

Глобально пока что вижу 2 предварительных варианта:
- Написать сеть самому с поддержкой от ЛЛМ;
- Воспользоваться уже предобученными сетями с некоторым файн тюнингом.

Каждый из этих вариантов будет выполнен в соответствующем ноутбуке)


### Links

[Decipher morse code audio with pure Python](https://www.youtube.com/watch?v=ylhAsdNq5IE&ab_channel=SanDiegoPython) - нашел вот такую ссылочку с обработкой сигнала морзе на чистом пайтон, мб удастся попробовать использовать
